#!/usr/bin/env python3
import math
from math import sqrt, cosh, acosh, asin, log, sin, atan2, pi, cos
import evdev
from evdev import UInput, ecodes as e
import pyudev
import sys
import threading
import os
import configparser
from dataclasses import dataclass
import time


button_name_to_code_map = {
    'middle': e.BTN_MIDDLE,
    'back': e.BTN_SIDE,
    'forward': e.BTN_EXTRA,
    'left': e.BTN_LEFT,
    'right': e.BTN_RIGHT,
}
button_code_to_name_map = {v: k for k, v in button_name_to_code_map.items()}
def get_button_code(button_name: str) -> int | None:
    button_name_lower = button_name.lower().strip()
    if button_name_lower in button_name_to_code_map:
        return button_name_to_code_map[button_name_lower]
    else:
        return e.ecodes.get(button_name_lower)

def get_button_name(button_code: int) -> str | None:
    if button_code in button_code_to_name_map:
        return button_code_to_name_map[button_code]
    else:
        return e.BTN.get(button_code, None)

def select_first_present_activation_button(button_codes: list[int], mouse_capabilities: list[int]) -> int | None:
    # Warn about invalid button names
    for button_code in button_codes:
        if button_code is None:
            print(f"Warning: Unknown button code '{get_button_name(button_code) or button_code}', skipping")
    
    for code in button_codes:
        if code in mouse_capabilities:
            return code

    print(f"Warning: The mouse had none of the buttons that were assigned by the config, the functionality will be inactive.")
    return None


# ideally most of this would be measured in mms rather than pixels, I haven't looked into it. Generally, computers don't give you accurate mms per pixel. Device manufacturers (and desktop environments) are in a state of sin and don't even try to provide it. So we just use pixels.
@dataclass
class Config:
    # The mouse buttons that can activate scrolling. Only the first one that is present on the mouse will be used, the rest are fallbacks.
    # We recommend setting this to 'forward' if you have it (It's usually more comfortable to click, and it's used less often, and apps never use it for drag actions), but not everyone has it, so it defaults to middle after that, and if you don't have middle, it'll default to right click.
    # Options: middle, back_proper, back (which is officially called BTN_SIDE), forward_proper, forward (which is officially called BTN_EXTRA), left, right, You can also use any of the standard linux/input.h button codes.
    activation_buttons: tuple[int, ...] = (e.BTN_FORWARD, e.BTN_EXTRA, e.BTN_SIDE, e.BTN_MIDDLE, e.BTN_RIGHT)
    # Scroll speed multiplier
    # Higher values = faster scrolling
    scroll_speed: float = 22.0
    # Invert scroll direction
    # true = page scrolling (drag down to move the page contents down, which means moving the view up)
    # false = view scrolling (drag down to move the view down, which means moving the page contents up)
    invert_scroll: bool = False
    # How far (in pixels) must be dragged before it'll consider it an intentional scroll and block the middle click events
    # Lower values = more sensitive. It's acceptable for this to be 1. It shouldn't be set to 0.
    drag_slop: float = 4.0
    # the threshold within which it can switch axis without making a commitment
    axis_decision_threshold: float = 13.0
    # if false, the software will do nothing and exit
    enable: bool = True
    # the limit on the length of the accumulator vector. The lower it is, the faster the perceived angle will seem to change. If it's too low, input device jitter will cause incorrect scrolling. Needs to be higher than both horizontal_movement_threshold and vertical_movement_threshold.
    accumulator_vector_limit: float = 5.0
    # effectively disabled by default, I expect no one will ever enable it, maybe we should remove it.
    # when biaxial scrolling is started, axis_break_max_jump is how far should we be able to jump back towards the actual position of the mouse. If you set this to inf, it can in theory make the axis breaking more obedient to the user's mouse movements, going right where they placed the mouse. If you set it to a small value, it creates a little sort of pop motion when biaxial scrolling activates, which makes it very clear to the user how biaxial scrolling works. But I'm not sure they really need this tutorialized...
    # thinking about this is making me think that maybe we should switch to a less strict axis breaking system
    axis_break_max_jump: float = 0.0

def load_config() -> Config:
    config = Config()
    config_paths = [
        '/etc/defter-scrolling.conf',
        os.path.expanduser('~/.config/defter-scrolling.conf')
    ]

    parser = configparser.ConfigParser()
    for path in config_paths:
        if os.path.exists(path):
            try:
                parser.read(path)
                if 'Settings' in parser:
                    ps = parser['Settings']
                    def take(key: str, parse_func):
                        if key in ps:
                            setattr(config, key, parse_func(key))
                    take('drag_slop', ps.getfloat)
                    take('scroll_speed', ps.getfloat)
                    take('invert_scroll', ps.getboolean)
                    take('accumulator_vector_limit', ps.getfloat)
                    take('axis_decision_threshold', ps.getfloat)
                    take('enable', ps.getboolean)
                    button_string = ps.get('activation_buttons')
                    if button_string:
                        button_codes = []
                        for b in button_string.split(','):
                            button_code = get_button_code(b.strip())
                            if button_code is not None:
                                button_codes.append(button_code)
                            else:
                                print(f"Warning: Unknown button name '{b.strip()}', skipping")
                        config.activation_buttons = tuple(button_codes)
                print(f"Loaded config from: {path}")
                break
            except Exception as ex:
                print(f"Warning: Error reading config from {path}: {ex}")

    return config

@dataclass
class State:
    # Shared state for mouse event handling across threads
    button_pressed: bool = False
    accumulator_vector: tuple[float, float] = (0.0, 0.0)
    # the drag that the mouse has undergone since drag start
    drag_total: tuple[float, float] = (0.0, 0.0)
    # the drag that has currently actually gone through as scroll events
    drag_total_realized: tuple[float, float] = (0.0, 0.0)
    decided: bool = False
    has_started_horizontal_scroll: bool = False
    has_started_vertical_scroll: bool = False
    lock: threading.Lock = None  # Thread lock for safe access

    def __post_init__(self):
        if self.lock is None:
            self.lock = threading.Lock()

# tombstone: This is a slightly imperfect solution to keeping a rolling average of a vector by length-limiting, it's framerate-dependent. I spent like a day assembling a framerate-independent implementation of this (ie, an implementation that would produce equivalent results for the cases `limited_vector_add(limited_vector_add(v, pull/2, limit), pull/2, limit))` and `limited_vector_add(v, pull, limit)`, and I got it together, but I decided at the end of it that it wasn't worth the trouble of testing it. But the code is in [tractrix pull tombstone.py](./tractrix pull tombstone.py).
def limited_vector_add(v: tuple[float, float], pull: tuple[float, float], limit: float) -> tuple[float, float]:
    nv = add(v, pull)
    m = magnitude(nv)
    if m > limit:
        return multiply(nv, limit/m)
    return nv
def add(a: tuple[float, float], b: tuple[float, float]) -> tuple[float, float]:
    return (a[0] + b[0], a[1] + b[1])
def subtract(a: tuple[float, float], b: tuple[float, float]) -> tuple[float, float]:
    return (a[0] - b[0], a[1] - b[1])
def magnitude(v: tuple[float, float]) -> float:
    return math.sqrt(v[0]**2 + v[1]**2)
def multiply(v: tuple[float, float], scalar: float) -> tuple[float, float]:
    return (v[0] * scalar, v[1] * scalar)
def is_more_horizontal_than_vertical(v: tuple[float, float]) -> bool:
    return not is_more_vertical_than_horizontal(v)
def is_more_vertical_than_horizontal(v: tuple[float, float]) -> bool:
    return abs(v[1]) >= abs(v[0])
def limit(v: float, limit: float) -> float:
    return max(min(v, limit), -limit)
def smax(a: float, b: float) -> float:
    return a if abs(a) >= abs(b) else b
def scroll_speed_for(distance_traveled: float, config: Config) -> int:
    return int(round(config.scroll_speed * distance_traveled * (-1 if config.invert_scroll else 1)))

def find_all_mice():
    context = pyudev.Context()
    mice = []

    for device in context.list_devices(subsystem='input'):
        # Only look at event devices
        if not device.device_node or not device.device_node.startswith('/dev/input/event'):
            continue

        # Use udev properties to properly identify mice
        # ID_INPUT_MOUSE is set by udev for actual pointer devices
        # Skip touchpads, touchscreens, tablets, etc.
        if device.get('ID_INPUT_MOUSE') == '1':
            # Explicitly skip touchpads and touchscreens even if they claim to be mice
            if device.get('ID_INPUT_TOUCHPAD') == '1':
                print(f"Skipping: {device.get('NAME', 'Unknown')} (touchpad)")
                continue
            if device.get('ID_INPUT_TOUCHSCREEN') == '1':
                print(f"Skipping: {device.get('NAME', 'Unknown')} (touchscreen)")
                continue
            if device.get('ID_INPUT_TABLET') == '1':
                print(f"Skipping: {device.get('NAME', 'Unknown')} (tablet)")
                continue

            try:
                input_device = evdev.InputDevice(device.device_node)
                # Double-check that it has mouse buttons
                caps = input_device.capabilities().get(e.EV_KEY, [])
                if any(btn in caps for btn in [e.BTN_LEFT, e.BTN_RIGHT]):
                    mice.append(input_device)
                    print(f"Found mouse: {input_device.name} ({input_device.path})")
            except (OSError, PermissionError) as ex:
                print(f"Warning: Could not access {device.device_node}: {ex}")
                continue

    return mice

def handle_mouse(mouse, ui, state: State, config: Config):
    print(f"Listening to: {mouse.name} ({mouse.path})")
    # Get the mouse's capabilities and select the first available button
    mouse_capabilities = mouse.capabilities().get(e.EV_KEY, [])
    activation_button_code = select_first_present_activation_button(config.activation_buttons, mouse_capabilities)

    # Grab the device to intercept all events
    try:
        mouse.grab()
    except (OSError, IOError) as ex:
        print(f"Failed to grab {mouse.name}: {ex}")
        return

    try:
        for event in mouse.read_loop():
            if event.type == e.EV_KEY and event.code == activation_button_code:
                with state.lock:
                    if event.value == 1:
                        state.button_pressed = True
                        # Don't forward the press event, only send the click when we know we're not scrolling (on release)
                    elif event.value == 0:
                        # Send button click if we didn't scroll enough
                        if state.button_pressed and magnitude(state.drag_total) < config.drag_slop:
                            ui.write(e.EV_KEY, activation_button_code, 1)
                            ui.write(e.EV_KEY, activation_button_code, 0)
                            ui.syn()
                        state.button_pressed = False
                        state.has_started_horizontal_scroll = False
                        state.has_started_vertical_scroll = False
                        state.accumulator_vector = (0.0, 0.0)
                        state.decided = False
                        state.drag_total = (0.0, 0.0)
                        state.drag_total_realized = (0.0, 0.0)

            elif event.type == e.EV_REL:
                with state.lock:
                    if not state.button_pressed:
                        # Forward events when middle button not pressed
                        ui.write(event.type, event.code, event.value)
                        ui.syn()
                    else:
                        previous_drag_total = state.drag_total
                        if event.code == e.REL_X:
                            state.drag_total = add(state.drag_total, (event.value, 0.0))
                        elif event.code == e.REL_Y:
                            state.drag_total = add(state.drag_total, (0.0, event.value))
                        state.decided = state.decided or magnitude(state.drag_total) > config.axis_decision_threshold
                        if (event.code == e.REL_X or event.code == e.REL_Y) and not state.decided:
                            # just snap to the axis that's closest to the drag total
                            if previous_drag_total != state.drag_total:
                                def to_axis(v: tuple[float, float]) -> tuple[float, float]:
                                    if is_more_horizontal_than_vertical(v):
                                        return (v[0], 0.0)
                                    else:
                                        return (0.0, v[1])
                                current = to_axis(state.drag_total)
                                previous = to_axis(previous_drag_total)
                                difference = subtract(current, previous)
                                if difference[0] != 0:
                                    ui.write(e.EV_REL, e.REL_HWHEEL_HI_RES, scroll_speed_for(difference[0], config))
                                if difference[1] != 0:
                                    ui.write(e.EV_REL, e.REL_WHEEL_HI_RES, -scroll_speed_for(difference[1], config))
                                ui.syn()
                                if is_more_horizontal_than_vertical(state.drag_total):
                                    state.has_started_horizontal_scroll = True
                                    state.has_started_vertical_scroll = False
                                else:
                                    state.has_started_vertical_scroll = True
                                    state.has_started_horizontal_scroll = False
                        elif event.code == e.REL_X:
                            state.drag_total = add(state.drag_total, (event.value, 0.0))
                            state.accumulator_vector = limited_vector_add(state.accumulator_vector, (event.value, 0.0), config.accumulator_vector_limit)
                            def move_by(d: float):
                                state.drag_total_realized = add(state.drag_total_realized, (d, 0.0))
                                ui.write(e.EV_REL, e.REL_HWHEEL_HI_RES, scroll_speed_for(d, config))
                                ui.syn()
                            if state.has_started_horizontal_scroll:
                                move_by(event.value)
                            elif is_more_horizontal_than_vertical(state.accumulator_vector):
                                state.has_started_horizontal_scroll = True
                                move_by(smax(event.value, limit(state.drag_total[0], config.axis_break_max_jump)))
                        elif event.code == e.REL_Y:
                            state.drag_total = add(state.drag_total, (0.0, event.value))
                            state.accumulator_vector = limited_vector_add(state.accumulator_vector, (0.0, event.value), config.accumulator_vector_limit)
                            def move_by(d: float):
                                state.drag_total_realized = add(state.drag_total_realized, (0.0, d))
                                # I don't know why but it seems like we have to invert the vertical scroll direction but not the horizontal. Maybe mouse and X11 coordinates are vertically flipped?
                                ui.write(e.EV_REL, e.REL_WHEEL_HI_RES, -scroll_speed_for(d, config))
                                ui.syn()
                            if state.has_started_vertical_scroll:
                                move_by(event.value)
                            elif is_more_vertical_than_horizontal(state.accumulator_vector):
                                state.has_started_vertical_scroll = True
                                move_by(smax(event.value, limit(state.drag_total[1], config.axis_break_max_jump)))
                        else:
                            # Forward other relative events unchanged
                            ui.write(event.type, event.code, event.value)
                            ui.syn()
                        

            else:
                # Forward all other events unchanged
                ui.write(event.type, event.code, event.value)
                ui.syn()

    except (OSError, IOError) as ex:
        # Device disconnected or I/O error
        print(f"Device disconnected: {mouse.name} ({mouse.path})")
        print(f"  Reason: {ex}")
    except Exception as ex:
        print(f"Unexpected error with {mouse.name}: {ex}")
        import traceback
        traceback.print_exc()
    finally:
        # Always ungrab the device on exit
        try:
            mouse.ungrab()
            print(f"Stopped listening to: {mouse.name}")
        except:
            pass  # Device might already be gone

def monitor_devices(ui, shared_state:State, config:Config, active_threads, active_threads_lock, stop_event, virtual_device_path):
    """Monitor for device connection/disconnection events"""
    print("Starting device monitor...")
    context = pyudev.Context()
    monitor = pyudev.Monitor.from_netlink(context)
    monitor.filter_by(subsystem='input')

    for device in iter(monitor.poll, None):
        if stop_event.is_set():
            break

        # Only process event devices
        if not device.device_node or not device.device_node.startswith('/dev/input/event'):
            continue

        if device.action == 'add' and device.get('ID_INPUT_MOUSE') == '1':
            # Skip touchpads, touchscreens, tablets
            if device.get('ID_INPUT_TOUCHPAD') == '1':
                continue
            if device.get('ID_INPUT_TOUCHSCREEN') == '1':
                continue
            if device.get('ID_INPUT_TABLET') == '1':
                continue

            # Check if this device is already being handled
            with active_threads_lock:
                if device.device_node in active_threads:
                    continue

            # Skip our own virtual device
            if device.device_node == virtual_device_path:
                continue

            # Give the device a moment to settle
            time.sleep(0.02)

            try:
                input_device = evdev.InputDevice(device.device_node)

                # Double-check it's not our virtual device by name
                if 'defter-scroller' in input_device.name:
                    continue

                # Check that it has mouse buttons
                caps = input_device.capabilities().get(e.EV_KEY, [])
                if any(btn in caps for btn in [e.BTN_LEFT, e.BTN_RIGHT]):
                    # Double-check it's not already being handled (race condition check)
                    with active_threads_lock:
                        if input_device.path in active_threads:
                            continue

                        print(f"\n=== New mouse connected: {input_device.name} ({input_device.path}) ===")

                        # Start a handler thread for the new device
                        thread = threading.Thread(
                            target=handle_mouse,
                            args=(input_device, ui, shared_state, config)
                        )
                        thread.daemon = True
                        thread.start()

                        # Store thread reference
                        active_threads[input_device.path] = thread

            except (OSError, PermissionError) as ex:
                print(f"Warning: Could not access newly connected device {device.device_node}: {ex}")

        elif device.action == 'remove':
            # Device removed - thread will exit automatically when read_loop fails
            device_path = device.device_node
            print(f"\n=== Device removed: {device_path} ===")
            # Clean up thread reference
            with active_threads_lock:
                if device_path in active_threads:
                    del active_threads[device_path]

def main():
    # Load configuration
    config = load_config()
    
    if not config.enable:
        print("defter scrolling has 'enabled' set to false in configuration, exiting.")
        sys.exit(0)

    mice = find_all_mice()

    # Create UInput with button and scroll wheel capabilities
    # We need to forward all mouse events, so we need to get the capabilities from a mouse
    if mice:
        # Use the first mouse's capabilities as a template
        mouse_caps = mice[0].capabilities()
        cap = {}
        if e.EV_KEY in mouse_caps:
            cap[e.EV_KEY] = mouse_caps[e.EV_KEY]
        if e.EV_REL in mouse_caps:
            rel_caps = mouse_caps[e.EV_REL].copy()
            # Ensure we have scroll wheel capabilities
            scroll_caps = [e.REL_HWHEEL_HI_RES, e.REL_WHEEL_HI_RES]
            for sc in scroll_caps:
                if sc not in rel_caps:
                    rel_caps.append(sc)
            cap[e.EV_REL] = rel_caps
    else:
        # Fallback if no mice found (shouldn't happen)
        cap = {
            e.EV_KEY: [e.BTN_LEFT, e.BTN_RIGHT, e.BTN_MIDDLE],
            e.EV_REL: [e.REL_X, e.REL_Y, e.REL_HWHEEL_HI_RES, e.REL_WHEEL_HI_RES],
        }

    ui = UInput(cap, name='defter-scroller')
    print(f"Created virtual input device: {ui.device.name}")
    virtual_device_path = ui.device.path
    print(f"Virtual device path: {virtual_device_path}")

    # Shared state across all mouse handler threads
    shared_state = State()

    # Track active threads and create stop event for clean shutdown
    active_threads = {}
    active_threads_lock = threading.Lock()
    stop_event = threading.Event()

    # Start handler threads for initial mice
    for mouse in mice:
        thread = threading.Thread(target=handle_mouse, args=(mouse, ui, shared_state, config))
        thread.daemon = True
        thread.start()
        active_threads[mouse.path] = thread

    # Start device monitor thread for hot-plug detection
    monitor_thread = threading.Thread(
        target=monitor_devices,
        args=(ui, shared_state, config, active_threads, active_threads_lock, stop_event, virtual_device_path)
    )
    monitor_thread.daemon = True
    monitor_thread.start()

    button_names = [get_button_name(code) for code in config.activation_buttons]
    if len(button_names) == 0:
        print(f"Warning: No activation buttons found, the functionality will be inactive.")
    elif len(button_names) > 1:
        print(button_names)
        print(f"\n=== Ready! Configured button priority: {', '.join(button_names)} ===")
    else:
        print(f"\n=== Ready! Hold {button_names[0]} button and move mouse ===")
    print("=== Monitoring for device changes... ===\n")

    try:
        # Keep the main thread alive and periodically clean up dead threads
        while True:
            time.sleep(1)

            # Clean up threads that have finished (devices that disconnected)
            with active_threads_lock:
                dead_paths = [path for path, thread in active_threads.items() if not thread.is_alive()]
                for path in dead_paths:
                    del active_threads[path]

            # If all mice are gone, wait for new ones
            if not active_threads:
                print("No active mice. Waiting for devices to be connected...")

    except KeyboardInterrupt:
        print("\nStopping...")
    finally:
        stop_event.set()
        ui.close()

if __name__ == "__main__":
    main()
