#!/usr/bin/env python3
import math
from math import sqrt, cosh, acosh, asin, log, sin, atan2, pi, cos
import evdev
from evdev import UInput, ecodes as e
import pyudev
import sys
import threading
import os
import configparser
from dataclasses import dataclass
import time


button_name_to_code_map = {
    'middle': e.BTN_MIDDLE,
    'back': e.BTN_SIDE,
    'forward': e.BTN_EXTRA,
    'left': e.BTN_LEFT,
    'right': e.BTN_RIGHT,
}
button_code_to_name_map = {v: k for k, v in button_name_to_code_map.items()}
def get_button_code(button_name: str) -> int | None:
    button_name_lower = button_name.lower().strip()
    if button_name_lower in button_name_to_code_map:
        return button_name_to_code_map[button_name_lower]
    else:
        return e.ecodes.get(button_name_lower)

def get_button_name(button_code: int) -> str | None:
    if button_code in button_code_to_name_map:
        return button_code_to_name_map[button_code]
    else:
        return e.BTN.get(button_code, None)

def select_first_present_activation_button(button_codes: list[int], mouse_capabilities: list[int]) -> int | None:
    # Warn about invalid button names
    for button_code in button_codes:
        if button_code is None:
            print(f"Warning: Unknown button code '{get_button_name(button_code) or button_code}', skipping")
    
    for code in button_codes:
        if code in mouse_capabilities:
            return code

    print(f"Warning: The mouse had none of the buttons that were assigned by the config, the functionality will be inactive.")
    return None


# ideally most of this would be measured in mms rather than pixels, I haven't looked into it. Generally, computers don't give you accurate mms per pixel. Device manufacturers (and desktop environments) are in a state of sin and don't even try to provide it. So we just use pixels.
@dataclass
class Config:
    # The mouse buttons that can activate scrolling. Only the first one that is present on the mouse will be used, the rest are fallbacks.
    # We recommend setting this to 'forward' if you have it (It's usually more comfortable to click, and it's used less often, and apps never use it for drag actions), but not everyone has it, so it defaults to middle after that, and if you don't have middle, it'll default to right click.
    # Options: middle, back_proper, back (which is officially called BTN_SIDE), forward_proper, forward (which is officially called BTN_EXTRA), left, right, You can also use any of the standard linux/input.h button codes.
    activation_buttons: tuple[int, ...] = (e.BTN_FORWARD, e.BTN_EXTRA, e.BTN_SIDE, e.BTN_MIDDLE, e.BTN_RIGHT)
    # Scroll speed multiplier
    # Higher values = faster scrolling
    scroll_speed: float = 21.0
    # Invert scroll direction
    # true = page scrolling (drag down to move the page contents down, which means moving the view up)
    # false = view scrolling (drag down to move the view down, which means moving the page contents up)
    invert_scroll: bool = False
    # the distance it has to travel along the horizontal axis before horizontal scrolling will go through. It's also required that the angle of the accumulator vector (length limit set below) exceeds 45° from the vertical.
    horizontal_movement_threshold: float = 8.0
    # How far (in pixels) to drag before considering it an intentional scroll and blocking the middle click events
    # Lower values = more sensitive. It's acceptable for this to be 1. It shouldn't be set to 0.
    drag_slop: float = 4.0
    # the distance it has to travel along the vertical axis before vertical scrolling will go through. It's also required that the angle of the accumulator vector (length limit set below) exceeds 45° from the horizontal.
    vertical_movement_threshold: float = 1.0
    # if false, the software will do nothing and exit
    enable: bool = True
    # the limit on the length of the accumulator vector. The lower it is, the faster the perceived angle will seem to change. If it's too low, input device jitter will cause incorrect scrolling. Needs to be higher than both horizontal_movement_threshold and vertical_movement_threshold.
    accumulator_vector_limit: float = 10.0

def load_config() -> Config:
    config = Config()
    config_paths = [
        '/etc/defter-scrolling.conf',
        os.path.expanduser('~/.config/defter-scrolling.conf')
    ]

    parser = configparser.ConfigParser()
    for path in config_paths:
        if os.path.exists(path):
            try:
                parser.read(path)
                if 'Settings' in parser:
                    ps = parser['Settings']
                    def take(key: str, parse_func):
                        if key in ps:
                            setattr(config, key, parse_func(key))
                    take('drag_slop', ps.getfloat)
                    take('scroll_speed', ps.getfloat)
                    take('invert_scroll', ps.getboolean)
                    take('horizontal_movement_threshold', ps.getfloat)
                    take('vertical_movement_threshold', ps.getfloat)
                    take('accumulator_vector_limit', ps.getfloat)
                    take('enable', ps.getboolean)
                    button_string = ps.get('activation_buttons')
                    if button_string:
                        button_codes = []
                        for b in button_string.split(','):
                            button_code = get_button_code(b.strip())
                            if button_code is not None:
                                button_codes.append(button_code)
                            else:
                                print(f"Warning: Unknown button name '{b.strip()}', skipping")
                        config.activation_buttons = tuple(button_codes)
                print(f"Loaded config from: {path}")
                break
            except Exception as ex:
                print(f"Warning: Error reading config from {path}: {ex}")

    if config.accumulator_vector_limit < config.horizontal_movement_threshold or config.accumulator_vector_limit < config.vertical_movement_threshold:
        print("Warning: accumulator_vector_limit is less than horizontal_movement_threshold or vertical_movement_threshold, this will cause incorrect scrolling. Setting accumulator_vector_limit to the higher of the two.")
        config.accumulator_vector_limit = max(config.horizontal_movement_threshold, config.vertical_movement_threshold)
    return config

@dataclass
class State:
    # Shared state for mouse event handling across threads
    button_pressed: bool = False
    accumulator_vector: tuple[float, float] = (0.0, 0.0)
    drag_total: float = 0.0
    has_started_horizontal_scroll: bool = False
    has_started_vertical_scroll: bool = False
    lock: threading.Lock = None  # Thread lock for safe access

    def __post_init__(self):
        if self.lock is None:
            self.lock = threading.Lock()

# tombstone: This is a slightly imperfect solution to keeping a rolling average of a vector by length-limiting, it's framerate-dependent. I spent like a day assembling a framerate-independent implementation of this (ie, an implementation that would produce equivalent results for the cases `limited_vector_add(limited_vector_add(v, pull/2, limit), pull/2, limit))` and `limited_vector_add(v, pull, limit)`, and I got it together, but I decided at the end of it that it wasn't worth the trouble of testing it. But the code is in [tractrix pull tombstone.py](./tractrix pull tombstone.py).
def limited_vector_add(v: tuple[float, float], pull: tuple[float, float], limit: float) -> tuple[float, float]:
    nv = add(v, pull)
    m = magnitude(nv)
    if m > limit:
        return multiply(nv, limit/m)
    return nv
def add(a: tuple[float, float], b: tuple[float, float]) -> tuple[float, float]:
    return (a[0] + b[0], a[1] + b[1])
def magnitude(v: tuple[float, float]) -> float:
    return math.sqrt(v[0]**2 + v[1]**2)
def multiply(v: tuple[float, float], scalar: float) -> tuple[float, float]:
    return (v[0] * scalar, v[1] * scalar)
def is_more_horizontal_than_vertical(v: tuple[float, float]) -> bool:
    return not is_more_vertical_than_horizontal(v)
def is_more_vertical_than_horizontal(v: tuple[float, float]) -> bool:
    return abs(v[1]) >= abs(v[0])

def scroll_speed_for(distance_traveled: float, config: Config) -> int:
    return int(round(config.scroll_speed * distance_traveled * (-1 if config.invert_scroll else 1)))

def find_all_mice():
    context = pyudev.Context()
    mice = []

    for device in context.list_devices(subsystem='input'):
        # Only look at event devices
        if not device.device_node or not device.device_node.startswith('/dev/input/event'):
            continue

        # Use udev properties to properly identify mice
        # ID_INPUT_MOUSE is set by udev for actual pointer devices
        # Skip touchpads, touchscreens, tablets, etc.
        if device.get('ID_INPUT_MOUSE') == '1':
            # Explicitly skip touchpads and touchscreens even if they claim to be mice
            if device.get('ID_INPUT_TOUCHPAD') == '1':
                print(f"Skipping: {device.get('NAME', 'Unknown')} (touchpad)")
                continue
            if device.get('ID_INPUT_TOUCHSCREEN') == '1':
                print(f"Skipping: {device.get('NAME', 'Unknown')} (touchscreen)")
                continue
            if device.get('ID_INPUT_TABLET') == '1':
                print(f"Skipping: {device.get('NAME', 'Unknown')} (tablet)")
                continue

            try:
                input_device = evdev.InputDevice(device.device_node)
                # Double-check that it has mouse buttons
                caps = input_device.capabilities().get(e.EV_KEY, [])
                if any(btn in caps for btn in [e.BTN_LEFT, e.BTN_RIGHT]):
                    mice.append(input_device)
                    print(f"Found mouse: {input_device.name} ({input_device.path})")
            except (OSError, PermissionError) as ex:
                print(f"Warning: Could not access {device.device_node}: {ex}")
                continue

    return mice

def handle_mouse(mouse, ui, shared_state: State, config: Config):
    print(f"Listening to: {mouse.name} ({mouse.path})")
    # Get the mouse's capabilities and select the first available button
    mouse_capabilities = mouse.capabilities().get(e.EV_KEY, [])
    activation_button_code = select_first_present_activation_button(config.activation_buttons, mouse_capabilities)

    # Grab the device to intercept all events
    try:
        mouse.grab()
    except (OSError, IOError) as ex:
        print(f"Failed to grab {mouse.name}: {ex}")
        return

    try:
        for event in mouse.read_loop():
            if event.type == e.EV_KEY and event.code == activation_button_code:
                with shared_state.lock:
                    if event.value == 1:
                        shared_state.button_pressed = True
                        # Don't forward the press event, only send the click when we know we're not scrolling (on release)
                    elif event.value == 0:
                        # Send button click if we didn't scroll enough
                        if shared_state.button_pressed and shared_state.drag_total < config.drag_slop:
                            ui.write(e.EV_KEY, activation_button_code, 1)
                            ui.write(e.EV_KEY, activation_button_code, 0)
                            ui.syn()
                        shared_state.button_pressed = False
                        shared_state.has_started_horizontal_scroll = False
                        shared_state.has_started_vertical_scroll = False
                        shared_state.accumulator_vector = (0.0, 0.0)
                        shared_state.drag_total = 0.0

            elif event.type == e.EV_REL:
                with shared_state.lock:
                    if shared_state.button_pressed:
                        shared_state.drag_total += abs(event.value)
                        # I don't know why but it seems like we have to invert the vertical scroll direction but not the horizontal. Maybe mouse and X11 coordinates are vertically flipped?
                        if event.code == e.REL_X:
                            # decide whether to unlock horizontal scroll on this event, or if it already is, be free
                            shared_state.accumulator_vector = limited_vector_add(shared_state.accumulator_vector, (event.value, 0.0), config.accumulator_vector_limit)
                            def move_by(d: float):
                                ui.write(e.EV_REL, e.REL_HWHEEL_HI_RES, scroll_speed_for(d, config))
                                ui.syn()
                            if shared_state.has_started_horizontal_scroll:
                                move_by(event.value)
                            elif (
                                magnitude(shared_state.accumulator_vector) > config.horizontal_movement_threshold and
                                is_more_horizontal_than_vertical(shared_state.accumulator_vector)
                            ):
                                move_by(shared_state.accumulator_vector[0])
                                shared_state.has_started_horizontal_scroll = True
                        elif event.code == e.REL_Y:
                            shared_state.accumulator_vector = limited_vector_add(shared_state.accumulator_vector, (0.0, event.value), config.accumulator_vector_limit)
                            def move_by(d: float):
                                ui.write(e.EV_REL, e.REL_WHEEL_HI_RES, -scroll_speed_for(d, config))
                                ui.syn()
                            if shared_state.has_started_vertical_scroll:
                                move_by(event.value)
                            elif (
                                magnitude(shared_state.accumulator_vector) > config.vertical_movement_threshold and
                                is_more_vertical_than_horizontal(shared_state.accumulator_vector)
                            ):
                                move_by(shared_state.accumulator_vector[1])
                                shared_state.has_started_vertical_scroll = True
                        else:
                            # Forward other relative events unchanged
                            ui.write(event.type, event.code, event.value)
                            ui.syn()
                    else:
                        # Forward events when middle button not pressed
                        ui.write(event.type, event.code, event.value)
                        ui.syn()

            else:
                # Forward all other events unchanged
                ui.write(event.type, event.code, event.value)
                ui.syn()

    except (OSError, IOError) as ex:
        # Device disconnected or I/O error
        print(f"Device disconnected: {mouse.name} ({mouse.path})")
        print(f"  Reason: {ex}")
    except Exception as ex:
        print(f"Unexpected error with {mouse.name}: {ex}")
        import traceback
        traceback.print_exc()
    finally:
        # Always ungrab the device on exit
        try:
            mouse.ungrab()
            print(f"Stopped listening to: {mouse.name}")
        except:
            pass  # Device might already be gone

def monitor_devices(ui, shared_state:State, config:Config, active_threads, active_threads_lock, stop_event, virtual_device_path):
    """Monitor for device connection/disconnection events"""
    print("Starting device monitor...")
    context = pyudev.Context()
    monitor = pyudev.Monitor.from_netlink(context)
    monitor.filter_by(subsystem='input')

    for device in iter(monitor.poll, None):
        if stop_event.is_set():
            break

        # Only process event devices
        if not device.device_node or not device.device_node.startswith('/dev/input/event'):
            continue

        if device.action == 'add' and device.get('ID_INPUT_MOUSE') == '1':
            # Skip touchpads, touchscreens, tablets
            if device.get('ID_INPUT_TOUCHPAD') == '1':
                continue
            if device.get('ID_INPUT_TOUCHSCREEN') == '1':
                continue
            if device.get('ID_INPUT_TABLET') == '1':
                continue

            # Check if this device is already being handled
            with active_threads_lock:
                if device.device_node in active_threads:
                    continue

            # Skip our own virtual device
            if device.device_node == virtual_device_path:
                continue

            # Give the device a moment to settle
            time.sleep(0.02)

            try:
                input_device = evdev.InputDevice(device.device_node)

                # Double-check it's not our virtual device by name
                if 'defter-scroller' in input_device.name:
                    continue

                # Check that it has mouse buttons
                caps = input_device.capabilities().get(e.EV_KEY, [])
                if any(btn in caps for btn in [e.BTN_LEFT, e.BTN_RIGHT]):
                    # Double-check it's not already being handled (race condition check)
                    with active_threads_lock:
                        if input_device.path in active_threads:
                            continue

                        print(f"\n=== New mouse connected: {input_device.name} ({input_device.path}) ===")

                        # Start a handler thread for the new device
                        thread = threading.Thread(
                            target=handle_mouse,
                            args=(input_device, ui, shared_state, config)
                        )
                        thread.daemon = True
                        thread.start()

                        # Store thread reference
                        active_threads[input_device.path] = thread

            except (OSError, PermissionError) as ex:
                print(f"Warning: Could not access newly connected device {device.device_node}: {ex}")

        elif device.action == 'remove':
            # Device removed - thread will exit automatically when read_loop fails
            device_path = device.device_node
            print(f"\n=== Device removed: {device_path} ===")
            # Clean up thread reference
            with active_threads_lock:
                if device_path in active_threads:
                    del active_threads[device_path]

def main():
    # Load configuration
    config = load_config()
    
    if not config.enable:
        print("defter scrolling has 'enabled' set to false in configuration, exiting.")
        sys.exit(0)

    mice = find_all_mice()

    # Create UInput with button and scroll wheel capabilities
    # We need to forward all mouse events, so we need to get the capabilities from a mouse
    if mice:
        # Use the first mouse's capabilities as a template
        mouse_caps = mice[0].capabilities()
        cap = {}
        if e.EV_KEY in mouse_caps:
            cap[e.EV_KEY] = mouse_caps[e.EV_KEY]
        if e.EV_REL in mouse_caps:
            rel_caps = mouse_caps[e.EV_REL].copy()
            # Ensure we have scroll wheel capabilities
            scroll_caps = [e.REL_HWHEEL_HI_RES, e.REL_WHEEL_HI_RES]
            for sc in scroll_caps:
                if sc not in rel_caps:
                    rel_caps.append(sc)
            cap[e.EV_REL] = rel_caps
    else:
        # Fallback if no mice found (shouldn't happen)
        cap = {
            e.EV_KEY: [e.BTN_LEFT, e.BTN_RIGHT, e.BTN_MIDDLE],
            e.EV_REL: [e.REL_X, e.REL_Y, e.REL_HWHEEL_HI_RES, e.REL_WHEEL_HI_RES],
        }

    ui = UInput(cap, name='defter-scroller')
    print(f"Created virtual input device: {ui.device.name}")
    virtual_device_path = ui.device.path
    print(f"Virtual device path: {virtual_device_path}")

    # Shared state across all mouse handler threads
    shared_state = State()

    # Track active threads and create stop event for clean shutdown
    active_threads = {}
    active_threads_lock = threading.Lock()
    stop_event = threading.Event()

    # Start handler threads for initial mice
    for mouse in mice:
        thread = threading.Thread(target=handle_mouse, args=(mouse, ui, shared_state, config))
        thread.daemon = True
        thread.start()
        active_threads[mouse.path] = thread

    # Start device monitor thread for hot-plug detection
    monitor_thread = threading.Thread(
        target=monitor_devices,
        args=(ui, shared_state, config, active_threads, active_threads_lock, stop_event, virtual_device_path)
    )
    monitor_thread.daemon = True
    monitor_thread.start()

    button_names = [get_button_name(code) for code in config.activation_buttons]
    if len(button_names) == 0:
        print(f"Warning: No activation buttons found, the functionality will be inactive.")
    elif len(button_names) > 1:
        print(button_names)
        print(f"\n=== Ready! Configured button priority: {', '.join(button_names)} ===")
    else:
        print(f"\n=== Ready! Hold {button_names[0]} button and move mouse ===")
    print("=== Monitoring for device changes... ===\n")

    try:
        # Keep the main thread alive and periodically clean up dead threads
        while True:
            time.sleep(1)

            # Clean up threads that have finished (devices that disconnected)
            with active_threads_lock:
                dead_paths = [path for path, thread in active_threads.items() if not thread.is_alive()]
                for path in dead_paths:
                    del active_threads[path]

            # If all mice are gone, wait for new ones
            if not active_threads:
                print("No active mice. Waiting for devices to be connected...")

    except KeyboardInterrupt:
        print("\nStopping...")
    finally:
        stop_event.set()
        ui.close()

if __name__ == "__main__":
    main()
