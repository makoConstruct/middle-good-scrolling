#!/usr/bin/env python3
import math
from math import sqrt, cosh, acosh, asin, log, sin, atan2, pi, cos
import evdev
from evdev import UInput, ecodes as e
import pyudev
import sys
import threading
import os
import configparser
from dataclasses import dataclass


# ideally most of this would be measured in mms rather than pixels, I haven't looked into it. Generally, computers don't give you accurate mms per pixel. Device manufacturers (and desktop environments) are in a state of sin and don't even try to provide it. So we just use pixels.
@dataclass
class Config:
    """Configuration settings for middle-click scrolling"""
    # Scroll speed multiplier
    # Higher values = faster scrolling
    scroll_speed: float = 30.0
    # Invert scroll direction
    # true = material scrolling (drag down to move the page contents down, which means scrolling up)
    # false = vulgar scrolling (drag down to scroll down, which means moving the page contents up)
    invert_scroll: bool = True
    # the distance it has to travel along the horizontal axis before horizontal scrolling will go through. It's also required that horizontal distance exceeds a certain angle, see below
    horizontal_movement_threshold: float = 8.0
    # How far (in pixels) to drag before considering it an intentional scroll and blocking the middle click events
    # Lower values = more sensitive. It's acceptable for this to be 1. It shouldn't be set to 0.
    drag_slop: float = 4.0
    # the distance it has to travel along the vertical axis before vertical scrolling will go through.
    vertical_movement_threshold: float = 1.0
    # if false, the software will do nothing and exit
    enable: bool = True
    # the limit on the length of the accumulator vector. The lower it is, the faster the perceived angle will seem to change. If it's too low, input device jitter will cause incorrect scrolling. Needs to be higher than both horizontal_movement_threshold and vertical_movement_threshold.
    accumulator_vector_limit: float = 10.0

def load_config() -> Config:
    """Load configuration from file or use defaults"""
    config = Config()
    config_paths = [
        '/etc/middle-good-scrolling.conf',
        os.path.expanduser('~/.config/middle-good-scrolling.conf')
    ]

    parser = configparser.ConfigParser()
    for path in config_paths:
        if os.path.exists(path):
            try:
                parser.read(path)
                if 'Settings' in parser:
                    if 'drag_slop' in parser['Settings']:
                        config.drag_slop = parser.getfloat('Settings', 'drag_slop')
                    if 'scroll_speed' in parser['Settings']:
                        config.scroll_speed = parser.getfloat('Settings', 'scroll_speed')
                    if 'invert_scroll' in parser['Settings']:
                        config.invert_scroll = parser.getboolean('Settings', 'invert_scroll')
                    if 'horizontal_movement_threshold' in parser['Settings']:
                        config.horizontal_movement_threshold = parser.getfloat('Settings', 'horizontal_movement_threshold')
                    if 'vertical_movement_threshold' in parser['Settings']:
                        config.vertical_movement_threshold = parser.getfloat('Settings', 'vertical_movement_threshold')
                    if 'accumulator_vector_limit' in parser['Settings']:
                        config.accumulator_vector_limit = parser.getfloat('Settings', 'accumulator_vector_limit')
                    if 'enable' in parser['Settings']:
                        config.enable = parser.getboolean('Settings', 'enable')
                print(f"Loaded config from: {path}")
                break
            except Exception as ex:
                print(f"Warning: Error reading config from {path}: {ex}")

    if config.accumulator_vector_limit < config.horizontal_movement_threshold or config.accumulator_vector_limit < config.vertical_movement_threshold:
        print("Warning: accumulator_vector_limit is less than horizontal_movement_threshold or vertical_movement_threshold, this will cause incorrect scrolling. Setting accumulator_vector_limit to the higher of the two.")
        config.accumulator_vector_limit = max(config.horizontal_movement_threshold, config.vertical_movement_threshold)
    return config

@dataclass
class State:
    """Shared state for mouse event handling across threads"""
    middle_pressed: bool = False
    accumulator_vector: tuple[float, float] = (0.0, 0.0)
    has_started_horizontal_scroll: bool = False
    has_started_vertical_scroll: bool = False

# tombstone: This is a slightly imperfect solution to keeping a rolling average of a vector by length-limiting, it's framerate-dependent. I spent like a day assembling a framerate-independent implementation of this (ie, an implementation that would produce equivalent results for the cases `limited_vector_add(limited_vector_add(v, pull/2, limit), pull/2, limit))` and `limited_vector_add(v, pull, limit)`, and I got it together, but I decided at the end of it that it wasn't worth the trouble of testing it. But the code is in [tractrix pull tombstone.py](./tractrix pull tombstone.py).
def limited_vector_add(v: tuple[float, float], pull: tuple[float, float], limit: float) -> tuple[float, float]:
    nv = add(v, pull)
    m = magnitude(nv)
    if m > limit:
        return multiply(nv, limit/m)
    return nv
def add(a: tuple[float, float], b: tuple[float, float]) -> tuple[float, float]:
    return (a[0] + b[0], a[1] + b[1])
def magnitude(v: tuple[float, float]) -> float:
    return math.sqrt(v[0]**2 + v[1]**2)
def multiply(v: tuple[float, float], scalar: float) -> tuple[float, float]:
    return (v[0] * scalar, v[1] * scalar)
def is_more_horizontal_than_vertical(v: tuple[float, float]) -> bool:
    return not is_more_vertical_than_horizontal(v)
def is_more_vertical_than_horizontal(v: tuple[float, float]) -> bool:
    return abs(v[1]) >= abs(v[0])

def scroll_speed_for(distance_traveled: float, config: Config) -> int:
    return int(round(config.scroll_speed * distance_traveled * (-1 if config.invert_scroll else 1)))

def find_all_mice():
    """Find all mouse devices using udev for proper device classification"""
    context = pyudev.Context()
    mice = []

    for device in context.list_devices(subsystem='input'):
        # Only look at event devices
        if not device.device_node or not device.device_node.startswith('/dev/input/event'):
            continue

        # Use udev properties to properly identify mice
        # ID_INPUT_MOUSE is set by udev for actual pointer devices
        # Skip touchpads, touchscreens, tablets, etc.
        if device.get('ID_INPUT_MOUSE') == '1':
            # Explicitly skip touchpads and touchscreens even if they claim to be mice
            if device.get('ID_INPUT_TOUCHPAD') == '1':
                print(f"Skipping: {device.get('NAME', 'Unknown')} (touchpad)")
                continue
            if device.get('ID_INPUT_TOUCHSCREEN') == '1':
                print(f"Skipping: {device.get('NAME', 'Unknown')} (touchscreen)")
                continue
            if device.get('ID_INPUT_TABLET') == '1':
                print(f"Skipping: {device.get('NAME', 'Unknown')} (tablet)")
                continue

            try:
                input_device = evdev.InputDevice(device.device_node)
                # Double-check that it has mouse buttons
                caps = input_device.capabilities().get(e.EV_KEY, [])
                if any(btn in caps for btn in [e.BTN_LEFT, e.BTN_RIGHT, e.BTN_MIDDLE]):
                    mice.append(input_device)
                    print(f"Found mouse: {input_device.name} ({input_device.path})")
            except (OSError, PermissionError) as ex:
                print(f"Warning: Could not access {device.device_node}: {ex}")
                continue

    return mice

def handle_mouse(mouse, ui, shared_state, config):
    print(f"Listening to: {mouse.name} ({mouse.path})")

    # Grab the device to intercept all events
    mouse.grab()

    try:
        for event in mouse.read_loop():
            if event.type == e.EV_KEY and event.code == e.BTN_MIDDLE:
                if event.value == 1:
                    shared_state.middle_pressed = True
                    # Don't forward the press event, only send a middle click when we know we're not scrolling (on release)
                elif event.value == 0:
                    shared_state.middle_pressed = False
                    if (
                        (shared_state.has_started_horizontal_scroll or shared_state.has_started_vertical_scroll) and
                        magnitude(shared_state.accumulator_vector) < config.drag_slop
                    ):
                        ui.write(e.EV_KEY, e.BTN_MIDDLE, 1)
                        ui.write(e.EV_KEY, e.BTN_MIDDLE, 0)
                    shared_state.has_started_horizontal_scroll = False
                    shared_state.accumulator_vector = (0.0, 0.0)
            elif event.type == e.EV_REL and shared_state.middle_pressed:
                # Convert mouse movement to scroll events
                # I don't know why but it seems like we have to invert the vertical scroll direction but not the horizontal. Maybe mouse and X11 coordinates are vertically flipped?
                if event.code == e.REL_X:
                    # decide whether to unlock horizontal scroll on this event, or if it already is, be free
                    shared_state.accumulator_vector = limited_vector_add(shared_state.accumulator_vector, (event.value, 0.0), config.accumulator_vector_limit)
                    moving_by = 0
                    if (
                        not shared_state.has_started_horizontal_scroll and
                        magnitude(shared_state.accumulator_vector) > config.horizontal_movement_threshold and
                        is_more_horizontal_than_vertical(shared_state.accumulator_vector)
                    ):
                        shared_state.has_started_horizontal_scroll = True
                        moving_by = shared_state.accumulator_vector[0]
                    else:
                        if shared_state.has_started_horizontal_scroll:
                            moving_by = event.value
                        else:
                            moving_by = 0
                    ui.write(e.EV_REL, e.REL_HWHEEL_HI_RES, scroll_speed_for(moving_by, config))
                    ui.syn()
                elif event.code == e.REL_Y:
                    shared_state.accumulator_vector = limited_vector_add(shared_state.accumulator_vector, (0.0, -event.value), config.accumulator_vector_limit)
                    moving_by = 0
                    if (
                        not shared_state.has_started_vertical_scroll and
                        magnitude(shared_state.accumulator_vector) > config.vertical_movement_threshold and
                        is_more_vertical_than_horizontal(shared_state.accumulator_vector)
                    ):
                        moving_by = shared_state.accumulator_vector[1]
                        shared_state.has_started_vertical_scroll = True
                    else:
                        if shared_state.has_started_vertical_scroll:
                            moving_by = event.value
                        else:
                            moving_by = 0
                    ui.write(e.EV_REL, e.REL_WHEEL_HI_RES, -scroll_speed_for(moving_by, config))
                    ui.syn()
                    
            else:
                # Forward all other events unchanged
                ui.write(event.type, event.code, event.value)
                ui.syn()

    except Exception as ex:
        print(f"Error with {mouse.name}: {ex}")
        import traceback
        traceback.print_exc()

def main():
    # Load configuration
    config = load_config()
    print(f"Configuration: drag_slop={config.drag_slop}, scroll_speed={config.scroll_speed}, invert_scroll={config.invert_scroll}")
    
    if not config.enable:
        print("middle good scrolling has 'enabled' set to false in configuration, exiting.")
        sys.exit(0)

    mice = find_all_mice()

    if not mice:
        print("No mice found!")
        sys.exit(1)

    print(f"Found {len(mice)} mouse device(s)")

    # Create UInput with button and scroll wheel capabilities
    # We need to forward all mouse events, so we need to get the capabilities from a mouse
    if mice:
        # Use the first mouse's capabilities as a template
        mouse_caps = mice[0].capabilities()
        cap = {}
        if e.EV_KEY in mouse_caps:
            cap[e.EV_KEY] = mouse_caps[e.EV_KEY]
        if e.EV_REL in mouse_caps:
            rel_caps = mouse_caps[e.EV_REL].copy()
            # Ensure we have scroll wheel capabilities
            scroll_caps = [e.REL_HWHEEL_HI_RES, e.REL_WHEEL_HI_RES]
            for sc in scroll_caps:
                if sc not in rel_caps:
                    rel_caps.append(sc)
            cap[e.EV_REL] = rel_caps
    else:
        # Fallback if no mice found (shouldn't happen)
        cap = {
            e.EV_KEY: [e.BTN_LEFT, e.BTN_RIGHT, e.BTN_MIDDLE],
            e.EV_REL: [e.REL_X, e.REL_Y, e.REL_HWHEEL_HI_RES, e.REL_WHEEL_HI_RES],
        }

    ui = UInput(cap, name='middle-click-scroller')
    print(f"Created virtual input device: {ui.device.name}")

    # Shared state across all mouse handler threads
    shared_state = State()

    threads = []
    for mouse in mice:
        thread = threading.Thread(target=handle_mouse, args=(mouse, ui, shared_state, config))
        thread.daemon = True
        thread.start()
        threads.append(thread)

    print("\n=== Ready! Hold middle-click and move mouse ===\n")

    try:
        for thread in threads:
            thread.join()
    except KeyboardInterrupt:
        print("\nStopping...")
    finally:
        ui.close()

if __name__ == "__main__":
    main()
